#pragma once

#include <Arduino.h>

/*
 * NightTransitionService
 * ----------------------
 * Плавный переход DAY <-> NIGHT.
 *
 * Задача сервиса — выдать коэффициент (0.0 .. 1.0), который используется
 * для смешивания (blend) цветов темы.
 *
 *  value() = 0.0  -> 100% DAY
 *  value() = 1.0  -> 100% NIGHT
 *
 * ВАЖНО:
 *  - Сервис НЕ рисует
 *  - Сервис НЕ знает про Theme / UI
 *  - Сервис НЕ принимает решений "ночь сейчас или нет"
 *    (это задача NightService)
 *
 * Типовой пайплайн:
 *   NightService (AUTO/ON/OFF) -> решает nightNow (bool)
 *   NightTransitionService::setTarget(nightNow)
 *   NightTransitionService::update() в loop()
 *   UI/Theme берет NightTransitionService::value() и смешивает цвета
 *
 * ДОПОЛНЕНИЕ (UX):
 *  value() выдаёт "готовое" значение для UI:
 *   - линейный фактор t (0..1) → easing smoothstep
 *   - затем "мягкое догоняние" (экспоненциальное сглаживание), чтобы:
 *       * убрать микродёргание из-за неровного dt
 *       * получить более "дорогой" закат/рассвет
 */

class NightTransitionService {
public:
    NightTransitionService();

    // ------------------------------------------------------------------------
    // control
    // ------------------------------------------------------------------------

    // Установка целевого состояния:
    //  true  -> идём в ночь
    //  false -> идём в день
    void setTarget(bool night);

    // Обновление перехода.
    // ДОЛЖНО вызываться регулярно (обычно в loop()).
    //
    // Сервис сам:
    //  - учитывает dt по millis()
    //  - "прибивает" фактор к 0/1 (snap), чтобы не было вечного дрейфа
    //  - ведёт флаг dirty, если значение заметно изменилось
    void update();

    // ------------------------------------------------------------------------
    // state
    // ------------------------------------------------------------------------

    // Возвращает true, если переход ещё не завершён.
    bool transitioning() const;

    // "Грязный" флаг: true если после последнего update()
    // значение value() изменилось "заметно" (по квантованию).
    //
    // Это полезно для оптимизации перерисовки:
    //   если dirty()==false -> можно не перерисовывать UI по теме.
    bool dirty() const;

    // Сброс dirty-флага (если экран/виджет уже обработал изменение).
    void clearDirty();

    // Цель, к которой идём (для отладки / диагностики).
    bool targetNight() const;

    // Фактический коэффициент (0..1) *до easing*.
    // Полезно для отладки.
    float rawFactor() const;

    // Коэффициент ночи (0..1) для логики.
    // Сейчас равен value().
    float nightFactor() const;

    // Универсальное значение для UI и Theme.
    // Именно ЭТОТ метод используйте для blend'а цветов.
    //
    // Здесь применяется:
    //  - easing (smoothstep)
    //  - сглаживание (inertia), чтобы переход выглядел "дороже"
    float value() const;

private:
    // easing: 3t^2 - 2t^3
    static float smoothstep(float t);

    // Квантование (0..255). Нужен для "заметного изменения" и dirty.
    static uint8_t quantize8(float t);

private:
    bool     _targetNight;   // к какому состоянию идём
    float    _t;             // текущий фактор (0.0 .. 1.0), линейный "прогресс"
    uint32_t _lastMs;        // время предыдущего update()

    // "Сглаженное" готовое значение для UI (после easing + inertia)
    float    _v;

    bool     _dirty;         // изменилось заметно с прошлого update()
    uint8_t  _lastQ;         // последний квант (0..255) для dirty

    // Скорость изменения t в миллисекунду.
    // 0.00025f ~= полный переход ~4 секунды.
    static constexpr float SPEED = 0.00025f;

    // Порог "прибивания" к краям.
    static constexpr float SNAP_EPS = 0.0015f; // ~0.15%

    // Сглаживание итогового value() (inertia).
    // Чем больше — тем быстрее догоняем.
    // 0.020..0.045 выглядит мягко на TFT.
    static constexpr float INERTIA = 0.035f;
};