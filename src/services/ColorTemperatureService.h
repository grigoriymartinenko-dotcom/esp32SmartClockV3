#pragma once

#include <Arduino.h>
#include <stdint.h>

#include "services/ThemeBlend.h"

/*
 * ColorTemperatureService
 * -----------------------
 * Сервис цветовой температуры интерфейса.
 *
 * Изначально у тебя сервис выдавал "готовые" цвета (text/icon/secondary).
 * Это ОК для раннего этапа, но сейчас мы переходим на правильный пайплайн:
 *
 *   ThemeBlend th = themeService.interpolate(t);   // Day/Night blend
 *   th = colorTemp.apply(th);                     // Temperature post-process
 *   UI.draw(th);                                  // UI знает только th
 *
 * ВАЖНО:
 *  - НЕ рисует
 *  - НЕ знает про экраны
 *  - НЕ знает про ThemeService / NightService
 *  - работает как ПОСТ-ФИЛЬТР над ThemeBlend
 *
 * Почему так лучше:
 *  - UI получает готовые цвета и не содержит логики "время суток"
 *  - можно применять температуру ко всем семантическим цветам темы (fg/accent/warn/...)
 *  - будущие эффекты (dim/gamma/contrast) добавляются тем же способом (post-process)
 */

// ============================================================================
// Color temperature modes
// ============================================================================
enum class ColorTemp : uint8_t {
    DAY = 0,        // нейтрально-белый
    EVENING,        // тёплый
    NIGHT           // очень тёплый, приглушённый
};

// ============================================================================
// Service
// ============================================================================
class ColorTemperatureService {
public:
    ColorTemperatureService();

    // ------------------------------------------------------------------------
    // control
    // ------------------------------------------------------------------------
    void set(ColorTemp t);
    ColorTemp current() const;

    // ------------------------------------------------------------------------
    // MAIN API (post-process over ThemeBlend)
    // ------------------------------------------------------------------------
    /*
     * apply()
     * -------
     * Применяет температурный сдвиг к ThemeBlend и возвращает новый ThemeBlend.
     *
     * Принцип:
     *  - фон (bg) оставляем как есть (стабильность + меньше шума/мерцаний)
     *  - "контентные" цвета (fg/accent/muted/warn/success) тёплим/охлаждаем
     */
    ThemeBlend apply(const ThemeBlend& in) const;

    // ------------------------------------------------------------------------
    // Legacy API (оставлено для совместимости)
    // ------------------------------------------------------------------------
    /*
     * Эти методы удобны, когда часть UI ещё не мигрировала на ThemeBlend-only.
     * Мы их НЕ удаляем, чтобы не ломать текущий код.
     *
     * Позже, когда весь UI будет получать цвета из ThemeBlend,
     * эти методы можно будет удалить или оставить как "пресеты".
     */
    uint16_t text() const;        // основной текст
    uint16_t icon() const;        // иконки
    uint16_t secondary() const;   // вторичные элементы

private:
    ColorTemp _current;

    // ------------------------------------------------------------------------
    // helpers
    // ------------------------------------------------------------------------
    static uint16_t rgb565(uint8_t r, uint8_t g, uint8_t b);

    /*
     * scale565()
     * ----------
     * Масштабирует каждый канал RGB565 на множители (в формате 8.8 fixed point).
     *
     * mul256 = 256  -> 1.0x
     * mul256 = 235*256/255 -> ~0.92x
     *
     * Без float: быстро, стабильно, предсказуемо.
     */
    static uint16_t scale565(uint16_t c, uint16_t rMul256, uint16_t gMul256, uint16_t bMul256);

    /*
     * Для каждого ColorTemp возвращаем множители каналов.
     * Мы использовали твои эталонные "температурные белые":
     *  DAY:     (255,255,255)
     *  EVENING: (255,235,210)
     *  NIGHT:   (255,210,170)
     *
     * Из них делаем коэффициенты:
     *  r = R/255, g = G/255, b = B/255
     */
    void multipliers(uint16_t& rMul256, uint16_t& gMul256, uint16_t& bMul256) const;
};